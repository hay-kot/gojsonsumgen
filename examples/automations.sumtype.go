// Code generated by gojsonsumtype DO NOT EDIT.
package examples

import (
	"encoding/json"
)

var (
	ActionTypeActionHTTP   = "action-http"
	ActionTypeActionPython = "action-python"
	ActionTypeActionShell  = "action-shell"
)

// ActionDef is a union type for the member types within the set. Marshalling and unmarshalling
// is done by the root type, and the raw JSON is saved until the type is narrowed, then we can
// unmarshal it into the correct type.
//
// You can narrow the type using the Is<Type> and As<Type> methods generated for each member type.
//
// ActionDef also supports the AsAny method, which returns the concrete type as an any. This
// is useful when you don't need to underlying type directly, but can cast it to another interface
// that the underlying type implements.
//
// Supported types:
//   - ActionHTTP
//   - ActionPython
//   - ActionShell
type ActionDef struct {
	Type string `json:"type"`
	raw  json.RawMessage
}

// UnmarshalJSON unmarshals the JSON into the root type (ActionDef) and saves the raw JSON.
// This is saved until we know which type it is, then we can unmarshal it into the correct type.
func (v *ActionDef) UnmarshalJSON(data []byte) error {
	v.raw = data
	var raw struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	v.Type = raw.Type
	return nil
}

func (v *ActionDef) MarshalJSON() ([]byte, error) {
	return v.raw, nil
}

// AsAny returns the concrete type as an any.
func (v *ActionDef) AsAny() any {
	switch v.Type {
	case ActionTypeActionHTTP:
		obj, _ := v.AsActionHTTP()
		return obj
	case ActionTypeActionPython:
		obj, _ := v.AsActionPython()
		return obj
	case ActionTypeActionShell:
		obj, _ := v.AsActionShell()
		return obj
	default:
		return nil
	}
}

// IsActionHTTP returns true if the value is ActionHTTP.
func (v *ActionDef) IsActionHTTP() bool {
	return v.Type == ActionTypeActionHTTP
}

// AsActionHTTP returns the value as ActionHTTP if it is a ActionHTTP.
func (v *ActionDef) AsActionHTTP() (ActionHTTP, bool) {
	if !v.IsActionHTTP() {
		return ActionHTTP{}, false
	}

	var obj ActionHTTP
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ActionHTTP{}, false
	}

	return obj, true
}

// IsActionPython returns true if the value is ActionPython.
func (v *ActionDef) IsActionPython() bool {
	return v.Type == ActionTypeActionPython
}

// AsActionPython returns the value as ActionPython if it is a ActionPython.
func (v *ActionDef) AsActionPython() (ActionPython, bool) {
	if !v.IsActionPython() {
		return ActionPython{}, false
	}

	var obj ActionPython
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ActionPython{}, false
	}

	return obj, true
}

// IsActionShell returns true if the value is ActionShell.
func (v *ActionDef) IsActionShell() bool {
	return v.Type == ActionTypeActionShell
}

// AsActionShell returns the value as ActionShell if it is a ActionShell.
func (v *ActionDef) AsActionShell() (ActionShell, bool) {
	if !v.IsActionShell() {
		return ActionShell{}, false
	}

	var obj ActionShell
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ActionShell{}, false
	}

	return obj, true
}

var (
	ShellTypeShellBash = "shell-bash"
	ShellTypeShellFish = "shell-fish"
	ShellTypeShellZsh  = "shell-zsh"
)

// ShellDef is a union type for the member types within the set. Marshalling and unmarshalling
// is done by the root type, and the raw JSON is saved until the type is narrowed, then we can
// unmarshal it into the correct type.
//
// You can narrow the type using the Is<Type> and As<Type> methods generated for each member type.
//
// ShellDef also supports the AsAny method, which returns the concrete type as an any. This
// is useful when you don't need to underlying type directly, but can cast it to another interface
// that the underlying type implements.
//
// Supported types:
//   - ShellBash
//   - ShellFish
//   - ShellZsh
type ShellDef struct {
	Type string `json:"type"`
	raw  json.RawMessage
}

// UnmarshalJSON unmarshals the JSON into the root type (ShellDef) and saves the raw JSON.
// This is saved until we know which type it is, then we can unmarshal it into the correct type.
func (v *ShellDef) UnmarshalJSON(data []byte) error {
	v.raw = data
	var raw struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}
	v.Type = raw.Type
	return nil
}

func (v *ShellDef) MarshalJSON() ([]byte, error) {
	return v.raw, nil
}

// AsAny returns the concrete type as an any.
func (v *ShellDef) AsAny() any {
	switch v.Type {
	case ShellTypeShellBash:
		obj, _ := v.AsShellBash()
		return obj
	case ShellTypeShellFish:
		obj, _ := v.AsShellFish()
		return obj
	case ShellTypeShellZsh:
		obj, _ := v.AsShellZsh()
		return obj
	default:
		return nil
	}
}

// IsShellBash returns true if the value is ShellBash.
func (v *ShellDef) IsShellBash() bool {
	return v.Type == ShellTypeShellBash
}

// AsShellBash returns the value as ShellBash if it is a ShellBash.
func (v *ShellDef) AsShellBash() (ShellBash, bool) {
	if !v.IsShellBash() {
		return ShellBash{}, false
	}

	var obj ShellBash
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ShellBash{}, false
	}

	return obj, true
}

// IsShellFish returns true if the value is ShellFish.
func (v *ShellDef) IsShellFish() bool {
	return v.Type == ShellTypeShellFish
}

// AsShellFish returns the value as ShellFish if it is a ShellFish.
func (v *ShellDef) AsShellFish() (ShellFish, bool) {
	if !v.IsShellFish() {
		return ShellFish{}, false
	}

	var obj ShellFish
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ShellFish{}, false
	}

	return obj, true
}

// IsShellZsh returns true if the value is ShellZsh.
func (v *ShellDef) IsShellZsh() bool {
	return v.Type == ShellTypeShellZsh
}

// AsShellZsh returns the value as ShellZsh if it is a ShellZsh.
func (v *ShellDef) AsShellZsh() (ShellZsh, bool) {
	if !v.IsShellZsh() {
		return ShellZsh{}, false
	}

	var obj ShellZsh
	if err := json.Unmarshal(v.raw, &obj); err != nil {
		return ShellZsh{}, false
	}

	return obj, true
}
